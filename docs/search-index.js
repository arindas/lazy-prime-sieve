var searchIndex = JSON.parse('{\
"lazy_prime_sieve":{"doc":"Usage","t":"FAADDNENGDDLLLLLLLLLLLLLMLLLLLLLLLLLLLLLMLLLLLLLLLLLLLLLLLLLLLLLLLMMMDRGLLLLLLFLLLFLLLLF","n":["primes","sieve","source","Entry","GenuineSieve","Identity","IterMultiple","Multiple","Table","TrialDivisionSieve","UnfaithfulSieve","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","cmp","composites","eq","from","from","from","from","from","into","into","into","into","into","into_iter","into_iter","into_iter","into_iter","key","multiply","next","next","next","next","partial_cmp","to_owned","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","with_source","with_source","with_source","factor","source","source","SpinWheel","WHEEL_2357_HOLES","Wheel","borrow","borrow_mut","clone","clone_into","default","from","integer_candidates","into","into_iter","next","odds_with_2","to_owned","try_from","try_into","type_id","wheel_2357"],"q":[[0,"lazy_prime_sieve"],[3,"lazy_prime_sieve::sieve"],[66,"lazy_prime_sieve::sieve::IterMultiple"],[69,"lazy_prime_sieve::source"]],"d":["Returns an Iterator of prime numbers.","Module providing sieves for generating primes.","","Table entry for genuine sieve of eratosthenes.","Genuine Sieve of eratosthenes implementation based on the …","","Creates an Iterator of integer multiples from the given …","","Table for maintaining composites in the genuine prime …","The modulus based memoized approach of generating primes …","Non-Recursive Rust implementation of the classic Haskell …","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","mechanism for generating numbers that are not multiples of …","Wheel holes for generating numbers that are not multiples …","Wheel mechanism for supporting SpinWheel","","","","","","Returns the argument unchanged.","2..","Calls <code>U::from(self)</code>.","","","","","","","",""],"i":[0,0,0,0,0,3,0,3,0,0,0,8,10,4,11,3,8,10,4,11,3,3,3,4,4,4,8,10,4,11,3,8,10,4,11,3,8,10,11,3,4,3,8,10,11,3,4,3,8,10,4,11,3,8,10,4,11,3,8,10,4,11,3,8,10,11,16,17,16,0,0,0,14,14,14,14,14,14,0,14,14,14,0,14,14,14,14,0],"f":[[[],1],0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[3,[2]]],[[3,[2]]]],[[]],[[4,4],5],0,[[4,4],6],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],0,[[3,7],3],[8,9],[[[10,[1]]],9],[[[11,[[0,[1,2]]]]],9],[[[3,[1]]],9],[[4,4],[[9,[5]]]],[[]],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],13],[[],13],[[],13],[[],13],[[],13],[1,8],[[],10],[[],11],0,0,0,0,0,0,[[]],[[]],[[[14,[2]]],[[14,[2]]]],[[]],[[],[[14,[15]]]],[[]],[[],[[0,[1,2]]]],[[]],[[]],[[[14,[1]]],9],[[],[[0,[1,2]]]],[[]],[[],12],[[],12],[[],13],[[],15]],"c":[],"p":[[8,"Iterator"],[8,"Clone"],[4,"IterMultiple"],[3,"Entry"],[4,"Ordering"],[15,"bool"],[15,"u64"],[3,"UnfaithfulSieve"],[4,"Option"],[3,"TrialDivisionSieve"],[3,"GenuineSieve"],[4,"Result"],[3,"TypeId"],[3,"SpinWheel"],[6,"Wheel"],[13,"Multiple"],[13,"Identity"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
